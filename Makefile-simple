# Makefile para Proyecto Individual - Sistema de Tracking DINEX
# Curso: Infraestructura como Código

.PHONY: help init plan apply destroy package clean test logs

# Variables
TF_DIR = terraform-simple
LAMBDA_DIR = lambda-simple

help: ## Mostrar esta ayuda
	@echo "Comandos disponibles:"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}'
	@echo ""
	@echo "Uso: make <comando>"

check: ## Verificar prerequisitos instalados
	@echo "Verificando prerequisitos..."
	@terraform --version || echo "ERROR: Terraform no instalado"
	@python --version || echo "ERROR: Python no instalado"
	@aws --version || echo "ERROR: AWS CLI no instalado"
	@echo "Verificación completada"

init: ## Inicializar Terraform
	@echo "Inicializando Terraform..."
	cd $(TF_DIR) && terraform init
	@echo "Inicialización completada"

package: ## Empaquetar funciones Lambda
	@echo "Empaquetando funciones Lambda..."
	@# Lambda tracking
	cd $(LAMBDA_DIR)/tracking && zip -r deployment.zip index.py
	@echo "Lambda tracking empaquetada"
	@# Lambda notifications
	cd $(LAMBDA_DIR)/notifications && zip -r deployment.zip index.py
	@echo "Lambda notifications empaquetada"
	@echo "Empaquetado completado"

validate: package ## Validar configuración de Terraform
	@echo "Validando configuración..."
	cd $(TF_DIR) && terraform fmt -check
	cd $(TF_DIR) && terraform validate
	@echo "Validación completada"

plan: package ## Ver plan de ejecución de Terraform
	@echo "Generando plan de Terraform..."
	cd $(TF_DIR) && terraform plan
	@echo "Plan generado"

apply: package ## Aplicar cambios de Terraform
	@echo "Aplicando cambios..."
	cd $(TF_DIR) && terraform apply
	@echo "Cambios aplicados exitosamente"

output: ## Mostrar outputs de Terraform
	@echo "Outputs del deployment:"
	@cd $(TF_DIR) && terraform output

destroy: ## Destruir infraestructura
	@echo "ADVERTENCIA: Esto eliminará toda la infraestructura"
	@echo "Presiona Ctrl+C para cancelar o Enter para continuar..."
	@read confirm
	cd $(TF_DIR) && terraform destroy

clean: ## Limpiar archivos temporales
	@echo "Limpiando archivos temporales..."
	@rm -f $(LAMBDA_DIR)/tracking/deployment.zip
	@rm -f $(LAMBDA_DIR)/notifications/deployment.zip
	@rm -rf $(TF_DIR)/.terraform
	@rm -f $(TF_DIR)/terraform.tfstate*
	@rm -f $(TF_DIR)/.terraform.lock.hcl
	@echo "Limpieza completada"

test-api: ## Probar el API (requiere jq instalado)
	@echo "Probando el API..."
	@API_URL=$$(cd $(TF_DIR) && terraform output -raw api_endpoint 2>/dev/null) && \
	if [ -z "$$API_URL" ]; then \
		echo "ERROR: No se pudo obtener la URL del API. Ejecuta 'make apply' primero."; \
	else \
		echo "URL del API: $$API_URL"; \
		echo ""; \
		echo "Test 1: Health Check"; \
		curl -s "$$API_URL/health" | python -m json.tool; \
		echo ""; \
		echo "Test 2: Crear tracking"; \
		curl -s -X POST "$$API_URL/tracking" \
			-H "Content-Type: application/json" \
			-d '{"tracking_id":"TRK001","package_id":"PKG001","location":"Lima - Almacén","status":"PROCESSING"}' | python -m json.tool; \
		echo ""; \
		echo "Test 3: Consultar tracking"; \
		curl -s "$$API_URL/tracking?tracking_id=TRK001" | python -m json.tool; \
	fi

logs: ## Ver logs de CloudWatch (tracking lambda)
	@FUNCTION_NAME=$$(cd $(TF_DIR) && terraform output -raw lambda_tracking_function_name 2>/dev/null) && \
	if [ -z "$$FUNCTION_NAME" ]; then \
		echo "ERROR: No se pudo obtener el nombre de la función Lambda"; \
	else \
		aws logs tail "/aws/lambda/$$FUNCTION_NAME" --follow; \
	fi

format: ## Formatear código Terraform
	@echo "Formateando código Terraform..."
	cd $(TF_DIR) && terraform fmt -recursive
	@echo "Formato aplicado"

cost: ## Estimar costos
	@echo "Estimación de costos mensuales (Free Tier):"
	@echo ""
	@echo "Lambda:        \$$0 (1M requests gratis)"
	@echo "DynamoDB:      \$$0 (25 GB + 25 RCU/WCU gratis)"
	@echo "API Gateway:   \$$3.50 (después de 1M gratis)"
	@echo "CloudWatch:    \$$2 (después de 5 GB gratis)"
	@echo "SNS:           \$$0 (1M publicaciones gratis)"
	@echo ""
	@echo "TOTAL ESTIMADO: \$$5-10/mes"
	@echo ""
	@echo "Nota: Los costos reales dependen del uso real"

all: check package validate plan ## Ejecutar check, package, validate y plan
	@echo "Pipeline completo ejecutado"

deploy: package apply output ## Empaquetar, aplicar y mostrar outputs
	@echo "Deployment completo"
